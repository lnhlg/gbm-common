package agvCollider

import (
	"fmt"
	"math"
	"sort"
	"sync"
	"time"
)

type Point struct{ X, Y float64 }

type State struct {
	X, Y     float64
	Theta    float64
	Velocity float64
}

type AGV struct {
	ID       int
	State    State
	Path     []Point
	Priority int
}

type Collision struct {
	Time float64
	PosX float64
	PosY float64
	AGV1 int
	AGV2 int
}

type Decision struct {
	StopAGV int
	Wait    float64 // æ¨èç­‰å¾…æ—¶é—´
}

type segment struct {
	StartTime, EndTime float64
	StartPoint         Point
	Vx, Vy             float64
}

func buildSegments(state State, path []Point) []segment {
	if state.Velocity <= 1e-6 {
		return nil
	}
	segs := []segment{}
	curr := Point{state.X, state.Y}
	t := 0.0
	for i := 0; i < len(path); i++ {
		next := path[i]
		dx, dy := next.X-curr.X, next.Y-curr.Y
		dist := math.Hypot(dx, dy)
		if dist < 1e-6 {
			curr = next
			continue
		}
		dur := dist / state.Velocity
		vx, vy := dx/dur, dy/dur
		segs = append(segs, segment{StartTime: t, EndTime: t + dur, StartPoint: curr, Vx: vx, Vy: vy})
		t += dur
		curr = next
	}
	return segs
}

func detectCollisionBetween(segs1, segs2 []segment, width float64, id1, id2 int) []Collision {
	collisions := []Collision{}
	r := width / 2.0
	for _, s1 := range segs1 {
		for _, s2 := range segs2 {
			start := math.Max(s1.StartTime, s2.StartTime)
			end := math.Min(s1.EndTime, s2.EndTime)
			if end <= start {
				continue
			}
			dx0 := s1.StartPoint.X - s2.StartPoint.X - s1.Vx*s1.StartTime + s2.Vx*s2.StartTime
			dy0 := s1.StartPoint.Y - s2.StartPoint.Y - s1.Vy*s1.StartTime + s2.Vy*s2.StartTime
			vx, vy := s1.Vx-s2.Vx, s1.Vy-s2.Vy
			A := vx*vx + vy*vy
			B := 2 * (dx0*vx + dy0*vy)
			C := dx0*dx0 + dy0*dy0 - (2*r)*(2*r)
			if A == 0 {
				if C <= 0 {
					collisions = append(collisions, Collision{start, s1.StartPoint.X, s1.StartPoint.Y, id1, id2})
				}
				continue
			}
			D := B*B - 4*A*C
			if D < 0 {
				continue
			}
			sqrtD := math.Sqrt(D)
			for _, cand := range []float64{(-B - sqrtD) / (2 * A), (-B + sqrtD) / (2 * A)} {
				if cand >= start && cand <= end {
					x1 := s1.StartPoint.X + s1.Vx*(cand-s1.StartTime)
					y1 := s1.StartPoint.Y + s1.Vy*(cand-s1.StartTime)
					collisions = append(collisions, Collision{cand, x1, y1, id1, id2})
				}
			}
		}
	}
	return collisions
}

func PredictAllCollisions(agvs []AGV, width float64) []Collision {
	segCache := map[int][]segment{}
	for _, agv := range agvs {
		segCache[agv.ID] = buildSegments(agv.State, agv.Path)
	}
	all := []Collision{}
	for i := 0; i < len(agvs); i++ {
		for j := i + 1; j < len(agvs); j++ {
			cs := detectCollisionBetween(segCache[agvs[i].ID], segCache[agvs[j].ID], width, agvs[i].ID, agvs[j].ID)
			all = append(all, cs...)
		}
	}
	sort.Slice(all, func(i, j int) bool { return all[i].Time < all[j].Time })
	return all
}

func MakeDecision(agvs []AGV, collisions []Collision) *Decision {
	if len(collisions) == 0 {
		return nil
	}
	first := collisions[0]
	var agv1, agv2 *AGV
	for i := range agvs {
		if agvs[i].ID == first.AGV1 {
			agv1 = &agvs[i]
		}
		if agvs[i].ID == first.AGV2 {
			agv2 = &agvs[i]
		}
	}
	if agv1 == nil || agv2 == nil {
		return nil
	}
	// è°ä¼˜å…ˆçº§ä½è°åœ
	stop := agv1
	if agv2.Priority < agv1.Priority {
		stop = agv2
	}
	return &Decision{StopAGV: stop.ID, Wait: 2.0}
}

// ğŸš¦ è°ƒåº¦ä¸­å¿ƒ
type Scheduler struct {
	mu    sync.Mutex
	AGVs  map[int]AGV
	Width float64
}

func NewScheduler(width float64) *Scheduler {
	return &Scheduler{AGVs: make(map[int]AGV), Width: width}
}

func (s *Scheduler) AddAGV(a AGV) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.AGVs[a.ID] = a
}

func (s *Scheduler) RemoveAGV(id int) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.AGVs, id)
}

func (s *Scheduler) UpdateAGV(a AGV) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.AGVs[a.ID] = a
}

// å‘¨æœŸæ€§è°ƒåº¦
func (s *Scheduler) RunScheduler(interval time.Duration, stopCh <-chan struct{}) {
	ticker := time.NewTicker(interval)
	for {
		select {
		case <-ticker.C:
			s.mu.Lock()
			allAGVs := []AGV{}
			for _, v := range s.AGVs {
				allAGVs = append(allAGVs, v)
			}
			collisions := PredictAllCollisions(allAGVs, s.Width)
			decision := MakeDecision(allAGVs, collisions)
			s.mu.Unlock()

			if len(collisions) == 0 {
				fmt.Println("è°ƒåº¦ä¸­å¿ƒ: æ²¡æœ‰æ£€æµ‹åˆ°å†²çª")
			} else {
				for _, c := range collisions {
					fmt.Printf("[é¢„æµ‹] AGV%d ä¸ AGV%d %.2fs åå¯èƒ½ç¢°æ’, ä½ç½®(%.2f, %.2f)\n",
						c.AGV1, c.AGV2, c.Time, c.PosX, c.PosY)
				}
				if decision != nil {
					fmt.Printf("[å†³ç­–] å»ºè®® AGV%d ç­‰å¾… %.1fs ä»¥é¿å…å†²çª\n", decision.StopAGV, decision.Wait)
				}
			}
		case <-stopCh:
			ticker.Stop()
			return
		}
	}
}
